{% extends "base.html" %}

{% block title %}
    Mitopo.de - Route Edit Page
{% endblock %}

{% block extra_assets %}
    {% load leaflet_tags %}
    {% load geojson_tags %}
    {% leaflet_js %}
    {% leaflet_css %}
    {% leaflet_js plugins="forms" %}
    {% leaflet_css plugins="forms" %}
{% endblock %}

{% block content %}
    <script>
     window.onload = function () {
	 map_init();
     }
    </script>

    <style>
     .mapobjects-info {
	 background: #476b4c;
	 margin: 0 auto;
	 padding-left: 7px;
	 padding-bottom: 7px;
	 padding-top: 7px;
	 padding-right: 0px;
	 bottom: 30px;
	 width: 1054px;
	 height: 1200px;
	 z-index: 1000;
	 border-radius: 5px;
     }

     .left_list {
	 float: left;    
     }

     #wrapper_select {
	 width: 800px;
	 border: 1px solid black;
	 overflow: hidden; /* will contain if #first is longer than #second */
     }

     #feedback {
	 font-size: 1.4em;
     }

     #selectable .ui-selecting {
         background: #FECA40;
     }

     #selectable .ui-selected {
         background: #F39814;
         color: white;
     }

     #selectable {
         display: inline-block;
         list-style-type: none;
         width: 300px;
         border: 1px solid red;
     }

     #selectable li {
         margin: 3px;
         padding: 0.4em;
         font-size: 1.4em;
         height: 18px;
     }

     #selected_routes .ui-selecting {
         background: #FECA40;
     }

     #selected_routes .ui-selected {
         background: #F39814;
         color: black;
     }

     #selected_routes {
         display: inline-block;
         list-style-type: none;
         width: 300px;
         overflow: hidden;
         border: 1px solid green;
     }

     #selected_routes li {
         margin: 3px;
         padding: 0.4em;
         font-size: 1.4em;
         height: 18px;
     }
     
    
     #route_list .ui-selecting {
         background: #FECA40;
     }
     #route_list .ui-selected {
         background: #F39814;
         color: black;
     }

     #route_list {
         display: inline-block;
         list-style-type: none;
         width: 300px;
         overflow: hidden;
         border: 1px solid green;
     }

     #routelist_div{
	 position: relative;
	 z-index: 1;
     }

     .custom-leaflet-container {
	 position: relative;
	 top: 0;
	 bottom: 0;
	 left: 0;
	 right: 0;
         width:  100%;
         height: 512px;
	 z-index: 1;
     }
    </style>

    <script type="text/javascript">
     // This is the widget part
     $(document).ready(function () {
	 function update_form() {

             // remove all entries from the list of chosen routes to re-populate
             $(".route_chooser").children().each(function () {
		 $(this).remove()
             });

             // populate list with input elements
             $("#selected_routes").children().each(function () {
		 var val = $(this).val();

		 // the value in the input elements is given by the route id
		 var text = '<input type="text" name="routes_onwall" value="'.concat(val).concat('" />');
		 $(".route_chooser").append(text);
             });
	 };

	 // the list of selected routes on the wall
	 $("#selected_routes").selectable({
             // on select we pop the element from the list
             selected: function (event, ui) {
		 var s = $(ui.selected);
		 s.remove();
		 // mark it as non-selected
		 s.removeClass('ui-selected');
		 // and put it back to the list of selectable routes
		 $("#selectable").append(s);
		 // the list of hidden input elements is updated as well
		 update_form();
             }
	 });

         // the list of selectable routes on the spot
         $("#selectable").selectable({
             // on select we pop the route from the list and add it to the
             // list of selected routes
             selected: function (event, ui) {
                 var s = $(ui.selected);
                 s.remove();
                 s.removeClass('ui-selected');
                 $("#selected_routes").append(s);
                 update_form();
             }
         });


         // the list of routes whose geometries are to edit
         $("#route_list").selectable({
             // on select we do something
             selected: function (event, ui) {
                 var s = $(ui.selected);
		 var geomid = s.val();
		 var geomstring = s.data('geom');
                 $("#testtext").text('Geometry '.concat(geomid).concat(' chosen. String ').concat(geomstring));

		 if(geomstring == "None"){
		     var newRouteEvent = new CustomEvent('newRouteEvent', { 'detail': {'geomid': geomid}});
		     document.dispatchEvent(newRouteEvent);

		 }else{
		     var editRouteEvent = new CustomEvent('editRouteEvent', {
			 'detail': {'geomid': geomid, 'geomstring': geomstring }});
		     document.dispatchEvent(editRouteEvent);
		 }
	     }	 
         });

     });
    </script>
{% endblock %}

{% block mapobjects_info %}
    You're looking at wall {{ wall.wall_name }}
    <br><br>
    <!-- css styles for the selectable list. TODO: put tags in css files -->
    <!-- We populate the list of routes on the spot. TODO: Generate this list dynamically and sort it by wall name -->
    <div id="wrapper_select">
	<div class="left_list">
            <ol id="selectable">
		{% for route in spot_routelist %}
                    <li class="ui-widget-content" name="route_onspot" value="{{ route.id }}">{{ route.route_name }}</li>
		{% endfor %}
            </ol>
	</div>
	<div class="right_list">
            <!-- This list contains the routes that are selected -->
            <ol id="selected_routes">
		{% for route in wall_routelist %}
                    <li class="ui-widget-content" name="route_selected" value="{{ route.id }}">{{ route.route_name }}</li>
		{% endfor %}
            </ol>
	</div>
    </div>

    <!-- The form redirects to the original url. The route_chooser dif is populated by hidden input elements -->
    <form method="POST" action="{{ request.path|urlencode }}">
        {% csrf_token %}
        <div class="route_chooser"></div>
        <input type="submit" value="speichern"/>
    </form>

    <br>
    <b>Edit route geometries</b>

    <div id="wallmap_id" class="custom-leaflet-container"></div>
    <script type="text/javascript">
     // The leaflet part
     function map_init () {
	 // Map init paperworks...
	 var img_dim_string = '{{ wall.get_bg_img_size }}';
	 
	 var img_dim = img_dim_string.split(',', 4);
	 var img_dim_x = parseFloat(img_dim[0]);
	 var img_dim_y = parseFloat(img_dim[1]);
	 var xzoom = parseFloat(img_dim[2]);
	 var yzoom = parseFloat(img_dim[3]);

	 var maxzoom = Math.max(xzoom, yzoom);

	 // we choose a default zoom level of 2 that matches either the width (approx.) or the
	 // height of the container
	 var minzoom = 2;
	 var startzoom = 2;

	 var map = L.map('wallmap_id', {
             minZoom: minzoom,
             maxZoom: maxzoom,
             crs: L.CRS.Simple
	 });

	 var southWest = map.unproject([0, img_dim_y], map.getMaxZoom());
	 var northEast = map.unproject([img_dim_x, 0], map.getMaxZoom());
	 map.setMaxBounds(new L.LatLngBounds(southWest, northEast));

         var aspectRatio = img_dim_x / img_dim_y;
	 if (aspectRatio < 1){
	     // we resize the container to fit an image with aspectRatio < 1
	     // the height is then fixed to 1024px
	     var wall_width = 1024 * aspectRatio;
             document.getElementById('wallmap').style.width = wall_width + "px";
	     document.getElementById('wallmap').style.height = 1024 + "px";
	 }

	 var wall_layer = L.tileLayer('{{ wall.get_tiles_url }}/{z}/{x}/{y}.png', {
             minZoom: minzoom, maxZoom: maxzoom,
             noWrap: false,
             tileSize: 256,
             continuousWorld: true,
	 });

	 wall_layer.addTo(map);

	 // we store the layers and the associated routeids in a list of dicts
	 // one element has geomid and a reference to the layer
	 var layerlist = {};

	 // the activeGeomId is used to denote the id of the currently edited
	 // or created geometry
	 var activeGeomId = null;
	 var activeFeatureGroup = null;

	 // We define a empty draw control and add it to the map
	 var drawControl = new L.Control.Draw({
	     draw: false,
	     edit: false});
	 map.addControl(drawControl);

	 function annotateGeom(layer, geomRouteName){
	     // here we want to add popups below the route geometries with
	     // the route names as labels

	     /* var firstPoint = layer._layers._latlngs[0];
		var lastPoint = layer._layers._latlngs[-1];

		which one is below the other?
		if(firstPoint[lat] < lastPoint[lat]){
	        var annotPoint = firstPoint;
		}
		else{
	        var annotPoint = lastPoint;
		}

		var popup = L.popup()
		.setLatLng(annotPoint)
		.setContent(geomRouteName)
		.openOn(map);*/
	 }

	 function resetDrawControl(newDrawControl){
	     // utility function to reset the draw controls and (in case) provide
	     // new draw controls
	     map.removeControl(drawControl);
	     if(!(newDrawControl)){
	     var newDrawControl = new L.Control.Draw({
		 draw: false,
		 edit: false});
	     }
	     // we need to overwrite the global variable
	     // otherwise we successively add draw controls
	     drawControl = newDrawControl;
	     map.addControl(drawControl);
	     }

	 
	 function onGeomSelect(e){
	     // This is the on-click handler of the geometries
	     // We only add edit controls.
	     activeLayer = e.target;
	     // Edit controls
	     resetDrawControl(new L.Control.Draw({
		 draw: false,
		 edit: {
		     featureGroup: activeLayer,
		     remove: true
		 }
	     }));

	 }

	 function addToLayerdict(geomid, layer){
	     // Utility function to add a pair of geomid and references
	     // to the layer to a dict, add the onClick handler and the layer to the map.
	     layer.addTo(map);
	     layer.on('click', onGeomSelect);
	     layer[geomid] = layer;
	 }
	 

	 // Now we initialize the existing route geometries
         {% if wall_routegeomlist %}
         var collection = {{ wall_routegeomlist|geojsonfeature|safe }};
	 var routenames = [];
	 var geomids = [];
	 {% for geom in wall_routegeomlist %}
	 routenames.push("{{ geom.route.route_name }}");
	 geomids.push("{{ geom.id }}");
	 {% endfor %}
	 for (var i = 0; i < collection.features.length; i++) {
	     if(collection.features[i].geometry){
		 var layer = L.geoJson(collection.features[i]);
		 
		 addToLayerdict(geomids[i], layer);
		 annotateGeom(layer, routenames[i]);
		 }
	 }
         {% endif %}
	    

	 
	 document.addEventListener('newRouteEvent', function (e) {

	     activeGeomId = e.detail.geomid;
	     
	     // Draw controls

	     resetDrawControl(new L.Control.Draw({
		 draw: {
		     polyline: true,
		     polygon: false,
		     rectangle: false,
		     circle: false,
		     marker: false},
		 edit: false
	     }));

	 });

	 document.addEventListener('editRouteEvent', function (e) {

	     activeGeomId = e.detail.geomid;
	     activeLayer = layerdict[activeGeomId];
	     
	     // Edit controls

	     resetDrawControl(new L.Control.Draw({
		 draw: false,
		 edit: {
		     featureGroup: activeLayer,
		     remove: true
		 }
	     }));

	 });

	 
	 map.on('draw:created', function (e) {

	     // we generate a geoJson layer to comply with the layers loaded
	     // from db.
	     var layer = L.geoJson(e.layer.toGeoJSON());

	     // we add this layer to the lookup table
	     if(activeGeomId){
		 addToLayerdict(activeGeomId, layer);
		 activeGeomId = null;
	     }
	     // remove the draw controls
	     resetDrawControl();
	     
	 });

	 map.on('draw:edited', function (e) {

	     // remove the draw controls
	     resetDrawControl();
	     activeGeomId = null;
	 });
	 

	 map.fitBounds(new L.LatLngBounds(southWest, northEast));


     }

    </script>

    <div id="routelist_div">
	route list (click to edit):
	<br>
	
	<ol id="route_list">
            {% for routegeom in wall_routegeomlist %}
		<!-- We save geometry and route name in the list -->
		<li class="ui-widget-content" value="{{ routegeom.id }}" data-geom="{{ routegeom.geom }}" data-name="{{ routegeom.route.route_name }}">{{ routegeom.route.route_name }}</li>
            {% endfor %}
	</ol>

	<br>
    </div>
    <div id="testtext">Test</div>
{% endblock %}
